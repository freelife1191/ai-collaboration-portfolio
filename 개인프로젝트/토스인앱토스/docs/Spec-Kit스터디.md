# 전문 개발자처럼 AI로 바이브코딩 하는 법 - SpecKit 가이드

`/specify init`을 실행하면, AI 코딩 에이전트가 구조화된 개발을 위해 다음 슬래시 명령어들을 사용할 수 있게 됨

## SpecKit

SpecKit의 체계적 접근 - Spec-Driven Development:

1. `/speckit.constitution`: Constitution (원칙) - 프로젝트 기본 원칙 설정
2. `/speckit.specify`: Specify (명세) - 무엇을 만들지 상세하게 정의
3. `/speckit.clarify`: Clarify (명확화) - 불분명한 부분을 질문으로 해소
4. `/speckit.plan`: Plan (계획) - 기술 스택과 아키텍처 결정
5. `/speckit.tasks`: Tasks (작업 분해) - 실행 가능한 단위로 쪼개기
6. `/speckit.implement`: Implement (구현) - 자동으로 코드 생성
7. `/speckit.analyze`: Analyze (검증) - 명세와 코드 일치 확인

**핵심 명령어 (Core Commands)**

Spec 기반 개발(Spec-Driven Development) 프로젝트 워크플로우를 위한 필수 명령어:

1. `/speckit.constitution`: (원칙) 프로젝트 기본 원칙 및 개발 가이드라인을 생성하거나 업데이트
2. `/speckit.specify`: (명세) 구축하려는 것(요구사항 및 사용자 스토리)을 정의

3. 여기에서 `/speckit.clarify` 사용해 명확화: (명확화) 명시되지 않은 영역을 명확화

4. `/speckit.plan`: (계획) 선택한 기술 스택으로 기술 구현 계획을 생성
5. `/speckit.tasks`: (작업 분해) 구현을 위한 실행 가능한 작업 목록을 생성

6. 여기에서 `/speckit.analyze` 사용해 문제점 검토: (검증) 여러 산출물 간의 일관성 및 커버리지 분석

7. `/speckit.implement`: (구현) 계획에 따라 기능을 구축하기 위한 모든 작업을 실행

8. 여기에서 `/speckit.checklist` 구현이 끝나고 최종 품질 검증:  (검증) 요구사항의 완전성, 명확성, 일관성을 검증하는 맞춤형 품질 체크리스트 생성 (예: "영어를 위한 유닛 테스트")

**선택적 명령어 (Optional Commands)**

향상된 품질 및 검증을 위한 추가 명령어:

- `/speckit.clarify`: 명시되지 않은 영역을 명확히 합니다 (`/speckit.plan` 전에 권장, 이전 명령어: `/quizme`)
- `/speckit.analyze`: 여러 산출물 간의 일관성 및 커버리지 분석 ( `/speckit.tasks` 이후, `/speckit.implement` 전에 실행)
- `/speckit.checklist`: 요구사항의 완전성, 명확성, 일관성을 검증하는 맞춤형 품질 체크리스트 생성 (예: "영어를 위한 유닛 테스트")

**환경 변수 (Environment Variables)**

- `SPECIFY_FEATURE`: 
  - Git이 아닌 리포지토리의 기능 감지를 재정의
  - Git 브랜치를 사용하지 않을 때 특정 기능 작업을 하려면 기능 디렉토리 이름(예: `001-photo-albums`)으로 설정
  - `/speckit.plan` 또는 후속 명령어를 사용하기 전에 작업 중인 에이전트의 컨텍스트 내에서 설정해야 함


```bash
$speckit.constitution

프로젝트 원칙을 만들어줘:

코드 품질:
- 간결하고 읽기 쉬운 코드
- 주석은 최소화하고 코드가 자체 설명되도록
- 중복 코드를 최소화 하며 주기적으로 스스로 리팩토링을 진행하며 개발을 진행함
- 코드는 성능과 품질을 최대한 신경쓰며 더 좋은 성능을 낼 수 있도록 검토하며 진행
- 다만 MVP 버전에서는 성능과 품질로 인해 기술스택이 오버스펙이 되어선 안됨 적절한 기술 선택이 필요

설계:
- 최초에는 MVP 버전으로 가볍게 설계하고 개발을 진행할 수 있도록 설계
- MVP 버전이 개발이 완료되면 단계별로 고도화 할 수 있도록 고도화 설계 로드맵을 제시
- 프로젝트 개발시 단계별, 단계의 세부 기능 단위 별로 계획을 세움
- 백엔드는 반드시 API Documents 를 잘 정의해야됨 Swagger API Docs 사용
- 서비스 아키텍처와 배포 아키텍처를 최대한 무료 또는 저비용 고효율로 효율적으로 잘 설계

테스트:
- 핵심 로직은 반드시 테스트 작성
- 최소 100% 코드 커버리지 목표
- 세부 기능 단위별로 반드시 테스트를 진행하고 반드시 테스트가 통과되어야만 다음 단위 기능 개발을 진행
- 하나의 단계의 모든 세부 기능 개발이 완료되면 해당 단계의 통합 테스트를 진행
- 통합 테스트까지 모두 완료되어야 다음 단계를 진행
- 세부 기능 개발 단위로 개발 완료시 커밋을 진행하며 반드시 테스트가 완료되어야만 커밋을 할 수 있음
- 푸시는 내가 지시할때만 푸시를 진행할 수 있음

사용자 경험:
- 직관적이고 빠른 인터페이스
- 3초 이내 응답 목표

성능:
- 불필요한 라이브러리 사용 금지, 필요시 반드시 허가를 받을 것!
```

```bash
$ speckit.specify

AI 기반 대화형 블로그 생성기를 만들어줘.

기능:
1. 사용자가 블로그 주제를 입력 (최소 5자)
2. AI가 4가지 질문을 순차적으로 제시:
  - 대상 독자는?
  - 글의 톤은? (전문적/캐주얼/교육적)
  - 핵심 키워드 3개는? (SEO용)
  - 글 길이는? (짧음/중간/길게)
3. 각 질문에 답변 가능하며, 이전 답변 수정도 가능
4. 모든 답변 완료 후 AI가 블로그 글 생성
5. 결과는 마크다운 형식으로 화면에 표시
6. 복사 버튼 제공

요구사항:
- SEO 최적화된 구조 (H1, H2, H3 계층)
- 키워드를 자연스럽게 배치
- 응답 시간 3초 이내 목표
- 모바일과 데스크톱 반응형 디자인
- 로딩 상태 표시
- 에러 핸들링 필수

제약사항:
- 로그인 기능 없음
- 데이터는 세션에만 저장 (영구 저장 없음)
```

```
2025년 기준 최신버전의 Next.js, shadcn/ui, Lucide, TailwindCSS, Framer Motion 기반으로 전체 업데이트 해줘
```

```bash
$speckit.constitution

프로젝트 원칙을 만들어줘:

코드 품질:
- 간결하고 읽기 쉬운 코드
- 주석은 최소화하고 코드가 자체 설명되도록
- 중복 코드를 최소화 하며 주기적으로 스스로 리팩토링을 진행하며 개발을 진행함
- 코드는 성능과 품질을 최대한 신경쓰며 더 좋은 성능을 낼 수 있도록 검토하며 진행
- 다만 MVP 버전에서는 성능과 품질로 인해 기술스택이 오버스펙이 되어선 안됨 적절한 기술 선택이 필요

설계:
- Toss 인앱토스 앱 개발을 위한 프로젝트 설계와 개발
- Supabase 를 최대한 활용해 간편하게 서비스를 개발
- 최초에는 MVP 버전으로 가볍게 설계하고 개발을 진행할 수 있도록 설계
- MVP 버전이 개발이 완료되면 단계별로 고도화 할 수 있도록 고도화 설계 로드맵을 제시
- 프로젝트 개발시 단계별, 단계의 세부 기능 단위 별로 계획을 세움
- 백엔드는 반드시 API Documents 를 잘 정의해야됨 사용할 수 있는 API Docs 자동화 서비스 구축
- 서비스 아키텍처와 배포 아키텍처를 최대한 무료 또는 저비용 고효율로 효율적으로 잘 설계

테스트:
- 핵심 로직은 반드시 테스트 작성
- 최소 100% 코드 커버리지 목표
- 세부 기능 단위별로 반드시 테스트를 진행하고 반드시 테스트가 통과되어야만 다음 단위 기능 개발을 진행
- 하나의 단계의 모든 세부 기능 개발이 완료되면 해당 단계의 통합 테스트를 진행
- 통합 테스트까지 모두 완료되어야 다음 단계를 진행
- 세부 기능 개발 단위로 개발 완료시 커밋을 진행하며 반드시 테스트가 완료되어야만 커밋을 할 수 있음
- 푸시는 내가 지시할때만 푸시를 진행할 수 있음

사용자 경험:
- 직관적이고 빠른 인터페이스
- 3초 이내 응답 목표

성능:
- 불필요한 라이브러리 사용 금지, 필요시 반드시 허가를 받을 것!
```

```
/speckit.plan 단위별로 꼭 모든 테스트가 완료 되어야만 커밋을 하고 다음 단위 개발을 진행해, 그리고 Free, Pro, Max, Team 구독 결제 기능도
추가되어야돼 구독 결제 스타일은 Claude 와 비슷하게 구성해줘
```

```
/speckit.tasks 단계를 나눠서 진행하고 단계별로 세부 기능 단위별로 또 나누고 세부 기능 별로 개발이 완료되면 반드시 테스트가 완료되어야만 커밋을 할 수 있고 커밋이 완료되고 다음 세부 기능을 개발하고 단계별 기능이 모두 개발 완료되면 통합 테스트를 진행하고 통합 테스트가 완료 되어야만 커밋을 하고 다음 단계를 진행할 수 있도록 진행해줘 
```

---

## Spec 주도 개발의 장점

### 1. 과도한 문서와 정보 제공의 문제점

* **집중력 분산 (Attention Dilution):** AI의 컨텍스트 윈도우(용량)가 커졌더라도, 핵심 로직과 부차적인 설명이 섞여 있으면 무엇이 우선순위인지 판단하지 못하고 엉뚱한 코드에 집중하게 된다.
* **지침 충돌 (Instruction Conflict):** 문서가 방대해질수록 과거의 요구사항과 현재의 요구사항이 충돌할 확률이 높다. AI는 이 경우 어떤 것이 '최신'인지 판단하기 어려워한다.
* **할루시네이션(환각) 유발:** 정보가 불분명하거나 너무 많으면 AI는 문맥을 메우기 위해 스스로 논리를 창조하기 시작하며, 이는 곧 버그로 이어진다.
* **토큰 낭비 및 속도 저하:** 불필요한 데이터를 처리하는 데 많은 자원을 소모하게 되어 응답 속도가 느려지고 효율성이 떨어진다.

---

### 2. Spec-kit 중심 개발의 장점

* **인지적 명확성 확보:** `Spec-kit`은 AI에게 "무엇을 해야 하는지"와 "무엇을 하지 말아야 하는지"의 경계를 명확히 설정해 준다. 덕분에 AI의 이해도가 비약적으로 상승한다.
* **모듈화된 업무 수행:** 전체가 아닌 '단계별 스펙'을 전달함으로써, AI가 한 번에 처리해야 할 논리적 단위를 쪼개어 정확도를 높일 수 있다.
* **검증 가능성 (Testability):** 스펙이 명확하면 결과물이 의도대로 나왔는지 확인하기 쉽습니다. "이 기능은 스펙 A를 만족하는가?"라는 질문에 Yes/No로 답할 수 있게 된다.
* **일관된 코드 품질:** 가이드라인이 간소화될수록 AI는 변수명, 아키텍처 패턴 등 사전에 정의된 규칙을 더 엄격하게 준수한다.

---

### 3. 성공적인 Spec-kit의 핵심 구성 요소

단순히 짧은 문서가 아니라, 다음과 같은 **'밀도 높은 정보'**가 포함되어야 한다.

| 구성 요소 | 설명 |
| --- | --- |
| **목표 (Goal)** | 이 단계에서 완성해야 할 최종 결과물에 대한 한 줄 정의 |
| **제약 사항 (Constraints)** | 사용 금지 라이브러리, 특정 디자인 패턴, 성능 제한 등 |
| **입출력 정의 (I/O)** | 함수나 컴포넌트가 받아야 할 데이터와 내보내야 할 데이터의 구조 |
| **정의된 워크플로우** | 작업의 우선순위와 논리적 단계 (Step-by-step) |

---

> **"적은 것이 더 많은 것이다 (Less is More)"**라는 원칙은 AI 프로그래밍에서 특히 강력하다.
> 불필요한 서술형 문장을 걷어내고 **구조화된 데이터(JSON, Markdown 등)** 형태로 스펙을 전달하는 습관이 코드의 질을 결정한다.